---
title:  "Real Mysql"

toc: true
toc_label: "go page"
toc_icon: "book"
toc_sticky : true

classes: wide

categories: 
  - mysql
tags:
  - mysql
last_modified_at: 2024-05-02T00:08:00-00:00
---
# Real My Sql

# ch4: 아키텍처

## MySQL 엔진 아키텍처
### MySQL의 구조
https://dev.mysql.com/doc/refman/8.0/en/pluggable-storage-overview.html#mysql-architecture-diagram   
![mysql-architecture]({{ site.baseurl }}/assets/images/study/architecture/mysql-architecture.png)

**Note:**      
MySQL Document Store를 사용하면 SQL 관계형 테이블 및 스키마 없는 JSON 컬렉션으로 작업할 수 있다.    
https://www.mysql.com/products/enterprise/document_store.html    
{: .notice--info}

MySQL은 대부분 프로그래밍 언어로부터 접근 방법을 모두 지원한다.(JDBC, ODBC 등)    
MySQL 서버는 **MySQL 엔진**과 **스토리지 엔진** 으로 구분된다.    
MySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.   

#### MySQL 엔진
MySQL엔진은 Connection Handler, SQL 파서, 전처리기, SQL 옵티마이저로 나뉜다.
- Connection Handler : 커넥션 및 쿼리 요청을 처리 담당
- SQL 인터페이스 : DML, DDL, Procedure, View 등 SQL 인터페이스 제공 담당
- SQL 파서(parser) : SQL문법 오류 탐지 및 SQL 쿼리 문장을 MySQL이 처리하기 좋은 토큰 단위로 나눠서 트리 형태로 파싱 하는 작업 담당
- SQL 옵티마이저(optimizer) : 쿼리를 얼마나 낮은 비용으로 효율적으로 처리할지 결정하는 역할 수행
  (쿼리 재작성, 스캔 순서 조정 및 인덱스 선택 작업 수행)
- 캐시와 버퍼 : 성능 향상을 위한 보조 저장소 기능 담당

#### 스토리지 엔진 
실제로 데이터를 처리하는 곳이다. 스토리지 엔진을 지정하면 지정된 스토리지 엔진이 작업들을 진행한다.
- 스토리지 엔진은 MySQL 엔진과 플러그인 형태로 연동/분리 가능하고 핸들러 API(핸들러 요청)를 통해 스토리지 엔진에 읽기/쓰기 요청이 가능

### MySQL 스레딩 구조
![mysql-threading]({{ site.baseurl }}/assets/images/study/architecture/mysql-threading.png)   
MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 작동하며, 포그라운드 스레드와 백그라운드 스레드로 구분할 수 있다.   

#### 포그라운드 스레드(클라이언트 스레드)

포그라운드 스레드는 최소 MySQL 서버에 접속된 클라이언트 수만큼 존재하며, 각 클라이언트 사용자의 요청 쿼리 문장을 처리한다.

커넥션이 종료되면, 해당 커넥션을 담당하던 스레드는 스레드 캐시로 되돌아 가며, 스레드 캐시에 일정 개수 이상의 스레드가 존재할 경우 스레드를 종료시켜 스레드 개수를 일정하게 유지한다.

포그라운드 스레드는 데이터를 데이터 버퍼나 캐시로부터 가져오며, 이 곳들에 데이터가 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 가져온다.

- MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드에서 처리한다.
- InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드에서 처리하고 디스크 쓰기 작업은 백그라운드 스레드가 처리한다.

#### 백그라운드 스레드(InnoDB)

- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

**Note:**      
가장 중요한 스레드는 **로그 스레드**와 버퍼의 데이터를 디스크로 내려쓰는 작업을 하는 **쓰기 스레드**이다.   
{: .notice--info}

데이터를 쓰는 아주 많은 작업은 백그라운드로 처리하기 때문에 디스크를 최적으로 사용할 수 있을 만큼 스레드 개수를 설정하는 것이 좋다.

### 메모리 할당 및 구조

MySQL에서 사용되는 메모리 공간은 글로벌 메모리 영역, 로컬 메모리 영역으로 구분할 수 있다.

#### 글로벌 메모리 영역

클라이언트 스레드 수와 무관하게 하나의 메모리 공간을 할당 받는다. 생성된 모든 글로벌 영역은 모든 스레드에 의해 공유된다.

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

***어댑티브 해시 인덱스*** 는 사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스   

#### 로컬 메모리 영역

세션 메모리 영역이라고도 하며, MySQL 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다.

로컬 메모리는 각 클리언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다.

- 정렬 버퍼(Sort buffer)
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

### 플러그인 스토리지 엔진 모델

MySQL의 독특한 구조 중 하나는 플러그인 모델이다.

MySQL은 이미 기본적으로 많은 스토리지 엔진을 가지고 있다. 하지만 사용자의 요구 조건을 만족시키기 위해 부가적인 기능을 더 제공하는 스토리지 엔진이 필요할 수 있으며, 이를 위해 직접 스토리지 엔진을 개발하는 것도 가능하다.

**MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야 한다**

### 컴포넌트

MySQL 8.0 부터 기존 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원된다.

- 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신 불가
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음
- 플러그인은 상호 의존 관계를 설정할 수 없어 초기화가 어려움

컴포넌트는 이러한 단점들을 보완하여 만들었다.

### 쿼리 실행 구조
SQL 요청 -> 쿼리 파서 -> 전처리기 -> 옵티마이저 -> 쿼리 실행기 -> 스토리지엔진
#### 쿼리 파서
쿼리 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업이다.
기본 적인 문법 오류는 이 과정에서 발견된다.
#### 전처리기
파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장의 문제점을 확인한다.
각 토큰을 테이블 이름, 컬럼 이름, 또는 내장 함수와 같은 개체를 매핑해 객체의 존재 여부와 접근 권한 등을 확인하는 과정을 수행한다.
#### 옵티마이저
**옵티마이저는 사용자의 요청으로 들어온 쿼리 문장의 효율적인 처리를 결정하는 역할을 맡으며, DBMS의 두뇌이다.**
#### 실행 엔진
실행 엔진과 핸들러는 DBMS의 손과 발에 비유할 수 있다.
실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러의 입입력으로 연결하는 역할을 수행한다.
#### 핸들러(스토리지 엔진)
MySQL 실행 엔진의 요청에 따라 데이터를 디스크에 저장하고 읽어오는 역할을 담당한다.
핸들러는 곧 스토리지 엔진을 의미한다.
#### 복제
2대 이상의 DBMS를 나눠서 데이터를 저장하는 방식이며, 사용하기 위한 최소 구성은 Master / Slave 구성을 하여야 한다.
#### 쿼리 캐시
SQL의 실행결과를 메모리에 캐시하여 동일 요청일 경우 즉시 결과 반환한다.
하지만 Select 만 있는 서비스가 아니면 오히려 동시 처리 성능이 떨어졌고 많은 버그의 원인이 되어 **Mysql 8.0 에 기능이 완전히 제거**되었다.
#### 스레드 풀
MySQL의 스레드 풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다 하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적이다. 

Percona Server의 스레드 풀 플러그인은 선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능도 제공한다.   
![mysql-thread-pool]({{ site.baseurl }}/assets/images/study/architecture/mysql-thread-pool.png)   
#### 트랜잭션 지원 메타데이터
MySQL 최신 버전부터는 테이블의 구조 정보나 스토어드 프로그램의 코드 관련 정보를 InnoDB의 테이블에 저장하도록 되었다.   
MySQL서버가 작동하는 데 기본적으로 필요한 테이블들을 묶어서 **시스템 테이블**이라는 테이블에 저장한다. 대표적으로 사용자 인증과 권한에 관련된 테이블들이 있다.   

## InnoDB 스토리지 엔진 아키텍처
InnoDB 스토리지 엔진은 MySQL 스토리지 엔진 중 가장 많이 사용되는 스토리지 엔진이다.   
InnoDB는 레코드 기반의 잠금을 제공하며, 덕분에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.   
![mysql-innodb-architecture-8-0]({{ site.baseurl }}/assets/images/study/architecture/mysql-innodb-architecture-8-0.png)   

### 프라이머리 키에 의한 클러스터링
InnoDB의 모든 테이블은 기본적으로 pk를 기준으로 클러스터링 되어 저장된다. 이 말은 pk값 순서대로  디스크에 저장된다는 뜻이며, 모든 세컨더리 인덱스는 레코드 주소 대신 pk값을 논리적인 주소로 사용한다.
pk가 클러스터링 인덱스이기 때문에 pk를 이용한 레인지 스캔은 상당히 빨리 처리되고 결과적으로 쿼리의 실행 계획에서 pk는 기본적으로 다른 보조 인덱스에 비해 비중이 놓게 설정된다.

### 외래 키 지원
외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능이다.
외래 키는 데이터베이스 서버 운영의 불편함 때문에 서비스용 데이터베이스에서 생성하지 않는 경우도 자주 있지만, 개발 환경의 데이터베이스에는 좋은 가이드 역할을 할 수 있다.
InnoDB 외래 키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고, 변경 시 참조된 테이블에 데이터가 존재하는지 체크해야 한다.

### MVCC(Multi Version Concurrency Control)
레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, 이 기능의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기의 제공에 있다. → InnoDB는 Undo log를 통해 구현
여기서 멀티 버전은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미다.
MySQL 서버에 설정된 격리수준에 따라 InnoDB 버퍼 풀, 언두 로그에 2개의 버전 중 상황에 맞는 버전의 레코드가 사용된다.

### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
InnoDB 스토리지 엔진은 MVCC 기술을 사용해 잠금을 걸지 않고 일기 작업을 수행하기 때문에 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고 바로 가능하다.
이러한 특징 때문에 UPDATE인 상태의 레코드를 다른 사용자가 SELECT 하더라도 이 UPDATE 트랜잭션이 SELECT 작업을 방해하지 않는다. 이를 잠금 없는 일관된 읽기라고 한다.

### 자동 데드락 감지
InnoDB 스토리지 엔진은 내무적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리한다.
InnoDB 스토리지 엔진은 데드락 감지 스레드를 가져 주기적으로 잠금 대기 그래프를 검사해 교착 상태의 트랜잭션들 중 하나를 강제 종료한다. 이때 기준은 트랜잭션 언두 로그 양이 적은 것 먼저 롤백된다.
동시 처리 스레드가 매우 많을 경우 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있다.

### 자동화된 장애 복구
InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위해 MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터에 대한 복구 작업이 자동으로 진행된다.
자동 복구 작업이 불가능할 경우 MySQL 서버 설정 파일에 `innodb_force_recovery`를 설정해 MySQL 서버를 시작해야 한다.

### InnoDB 버퍼 풀
InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다.
쓰기 작업을 지연시켜 일괄 작업을 처리할 수 있게 해주는 버퍼 역할도 한다.
InnoDB 버퍼 풀의 크기를 적절히 작은 값으로 설정해 조금씩 증가시키는 방법을 사용하는 것이 좋다.

### Double Write Buffer
InnoDB 스토리지 엔진의 리두 로그는 공간의 낭비를 막기 위해 변경된 내용만 기록하기 때문에 문제 발생시, 내용은 복구가 불가능할 수도 있다. → Partial-page라 한다.
이를 Double - Write로 해결한다

### 언두 로그
InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 전 버전의 데이터를 별도로 백업한다. 이 백업된 데이터를 언두 로그라고 한다.
언두 로그는 백업해둔 이전의 데이터를 활용해 트랜잭션 롤백 시 데이터 복구를 하고, 변경중인 데이터에 다른 커넥션이 접근해 데이터를 조회할 경우 격리 수준에 맞게 변경중인 데이터가 아닌 백업 데이터를 읽어 반환한다.

### 체인지 버퍼
RDBMS의 레코드 변화시에는 데이터 파일을 변경할 뿐만 아니라 해당 테이블의 인덱스 또한 업데이트 해야 한다. 이때, 디스크를 읽는 작업이 필요하기 때문에 많은 자원을 소모할 수도 있다.
InnoDB는 변경해야 할 인덱스가 버퍼 풀에 있으면 바로 업데이트를 하지만 디스크로부터 읽어와야 할 경우 임시 공간에 둔다 이 공간을 체인지 버퍼라고 한다.

### 리두로그 및 로그 버퍼
리두 로그는 영속성과 가장 밀접하게 연관되어 있다.
대부분의 데이터베이스 서버는 데이터 변경 내용을 로그로 먼저 기록 → 쓰기 보다 읽기 성능을 고려(일반적으로 읽기보다 쓰기가 상대적으로 큰 비용 필요)
데이터베이스 서버는 쓰기 비용이 낮은 자료구조를 가진 리두 로그를 갖고 있으며 비정상 종료 시 리두 로그의 데이터를 사용해 복구한다.
데이터를 복구하거나 대용량 데이터를 한번에 적재하는 경우 리두 로그를 비활성화 해 데이터 적재 시간을 단축시킬 수도 있다.

```
mysql> ALTER INSTANCE DISABLE INNODB REDO_LOG;
```

데이터 적재 완료 후 반드시 리두 로그를 활성하 하자!

### 어댑티브 해시 인덱스
사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스이다.
어댑티브 해시 인덱스는 B-Tree의 검색 시간을 줄여주기 위한 기능이다.
어댑티브 해시 인덱스가 도움이 되는 경우

- 디스크 읽기가 많은 경우
- 특정 패턴의 쿼리가 많은 경우(조인, LIKE 패턴검색)
- 매우 큰 데이터를 가진 테이블 레코드를 폭넓게 읽는 경우

성능 향상에 도움이 많은 경우

- 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(디스크 읽기가 적음)
- 동등 조건 검색이 많은 경우
- 쿼리가 데이터 중에서 일부 데이터에만 집중된 경우

## MySQL 로그 파일
로그 파일을 이용하면 MySQL 서버의 깊은 내부 지식이 없이도 MySQL의 상태나 부하를 일으키는 원인을 쉽게 찾아 해결할 수 있다.

### 에러 로그 파일
MySQL이 실행되는 도중에 발생하는 에러나 경고 메시지가 출력되는 로그 파일.
위치는 MySQL 설정 파일(`my.cnf`)에서 `log_error`라는 파라미터 경로에 생성

### 제너럴 쿼리 로그 파일
쿼리 로그 파일의 경로는 `general_log_file`이란 파라미터에 설정돼 있다.
이 로그 파일을 검토해 MySQL 서버에서 실행되는 쿼리에는 어떤 것들이 있는지 검토할 수 있다.

### 슬로우 쿼리 로그
MySQL 서버의 쿼리  중 정기적인 점검을 위한 튜닝에서 어떤 쿼리가 문제의 쿼리인지 판단하기는 어려운데, 이때 슬로우 쿼리 로그가 도움이 된다.
`long_query_time` 시스템 변수에 설정된 시간 이상이 소요된 쿼리가 모두 기록된다. 즉, 슬로우 쿼리 로그 파일에 기록된 쿼리는 `long_query_time` 보다 시간이 오래 걸린 정상적인 쿼리이다.